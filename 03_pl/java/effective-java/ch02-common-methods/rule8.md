> 본 글은 [이펙티브 자바 2nd](https://book.naver.com/bookdb/book_detail.nhn?bid=8064518)를
읽고 개인적으로 학습한 내용을 복습하기 위해 작성된 글로 내용상 오류가 있을 수 있습니다.
오류가 있다면 지적 부탁드리겠습니다.


# rule 8. `equals`를 재정의할 때는 일반 규약을 따르라.

## 8.1 재정의를 하지 않는 경우

`equals`메서드를 오버라이드하기 쉬워 보이지만 실수할 여지도 있고, 그 결과가 끔찍할 수 있다.
그런 문제를 해결하는 방법은 오버라이드하지 않는 것이 좋다. 아래의 조건을 만족한다면
오버라이드 하지 않아도 좋다.

- 각각 객체가 고유할 경우
  - 값(value) 대신 활성 개체(active entity)를 나타내는 `Thread`같은 클래스가 이 조건 부합
- 클래스에 "논리적 동일성" 검사 방법이 필요 없을 경우
  - `Random` 클래스에서 재정의할 수도 있었지만 이 클래스를 설계한 사람들은 원치 않을거라 생각함
- 상위 클래스에서 재정의한 `equals`가 하위 클래스에서 사용하기에도 적당한 경우
  - `Set`클래스는 `AbstractSet`의 `equals`메서드 그대로 사용
  - `List`클래스는 `AbstractList`의 `equals`메서드 그대로 사용
  - `Map`클래스는 대체로 `AbstractMap`의 `equals`메서드 그대로 사용
- 클래스가 `private` 또는 `package-private`로 선언되었고, `equals`메서드를 호출할 일이 없을 경우

```java
@Override
public Boolean equals(Object o) {
  throw new AssertionError(); // 호출되면 안되는 메서드를 호출했다는 의미
}
```

## 8.2 재정의를 해야하는 경우

- 객체의 동일성(object equality)이 아닌 논리적 동일성(logical equality)의 개념을 지원하는
클래스인 경우
- 상위 클래스의 `eqauls`가 하위 클래스의 필요를 충족하지 못한 경우

위의 조건에 값 클래스(value class)는 대체적으로 부합한다.
*여기서 값 클래스는 `Integer`나 `Date`처럼 단순히 어떤 값을 표현하는 클래스를 말한다.*

## 8.3 재정의를 할 필요가 없는 경우

- 개체 동제 기능을 사용해 값마다 최대 하나의 객체만 존재하도록 제한하는 클래스인 경우
- 다시말해 싱글톤인 경우를 말한다. 그리고 `enum`이 이 범주에 들어간다.

## 8.4 `equals`메서드를 정의할 때 준수해야 하는 일반 규약

`eqauls` 메서드는
