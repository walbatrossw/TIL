# Clean Coders : OOP Part

[클린 코더스 강의 1. 소개 및 OOP ](https://www.youtube.com/watch?v=60lLSe1phks&index=1&list=PLuLb6MC4SOvXCRePHrb4e-EYadjZ9KHyH)

[클린 코더스 강의 2. OOP Part2](https://www.youtube.com/watch?v=D8_mbdoGPrg&index=2&list=PLuLb6MC4SOvXCRePHrb4e-EYadjZ9KHyH)


## 1. Why Clean Code?
**사람이 이해할 수 있는 코드(읽을수 있는 코드) VS, 기계가 이해할 수 있는 코드(돌아가는 코드)**

- 누구나 이해할 수 있는 코드가 좋다는 것을 안다. 하지만 실무에서는 바쁘기 때문에 빠르게 코드를 작성해야만 한다.
- 그렇기 때문에 TDD, Acceptance Test, 리팩토링, 리뷰를 할 수 없거나 안하게 된다.
- 이렇게 프로젝트를 진행하고, 론칭되면 그 이후에 발생하는 자잘한 버그들이 쉽게 수정이 되질 않는다.
- 통계적으로 본다면 코드 1라인을 수정하면 다시 버그가 3라인에서 발생된다.
- 즉 다시말하자면 버그를 수정하면서 새로운 버그가 발생하게 되는 것이다.
- 개발에 있어 앞부분에 시간과 공을 들이는 것이 처음에는 시간과 비용이 많이 드는 것처럼 보이지만 전체시간으로 본다면 결코 많이 드는 것만은 아니다.
- 개발을 하기 앞서 종이에 한번이라도 써보면서 내가 무엇을 개발할지 고민해보는 것이 중요하다.
- 내가 구현하려는 것이 무엇인지 고민해보고 실제로 종이나 화이트보드에 작성하는 습관을 가져보자.
- 리팩토링과 리스트럭쳐링은 엄연히 다르다.
- 실무에서는 프로젝트를 진행하고 나서 리팩토링을 할 시간이 없기 때문에 지금 현재에 충실히 깔끔한 코드를 작성하는 것이 매우 중요하다.

>소프트웨어는 한번 작성되면 최소 10번 이상 읽힌다. 그래서 대충 돌아가게 작성하면 안되며, 읽기 편하도록 작성해야한다.
대다수 개발자는 신규 프로젝트보다는 유지보수성 업무를 수행하는 경우가 많다. 그렇다면 답은 명확하다. 돌아가는 코드가 아닌 읽을 수 있는 코드가 중요하다는 것을


## 2. Why OOP?
**OOP(객체지향) VS, Procedural(절차지향)**
- 절차지향
  * 데이터를 중간에 두고 그 데이터를 공유해서 사용하는 여러 함수들과 그 함수를 사용하는 또다른 함수가 존재한다.
  * 만약 데이터가 변경이 생기면 여러 함수에서 문제가 발생할 수 있다.
  * 절차지향의 경우 진입장벽이 상대적으로 낮고 쉽다.
- 객체지향
  * 데이터를 공유해서 사용하지 않는다.
  * 데이터와 코드가 캡슐화(Encapsulated)
  * 데이터와 그 데이터를 조작하는 코드의 변경은 외부에 영향을 미치지 않는다.
  * 응집도가 높고 결합도가 낮다.
  * 외부에 노출된 인터페이스만 변경되지 않는다면 프로시저를 실행하는데 필요한 만큼의 데이터만 가진다.
  * 진입장벽이 높고 어렵다.
  * 현실적으로 어렵기 때문에 절차지향에서 객체지향으로 수정하는 리팩토링을 하는 것이 현실적이다.

> 소프트웨어는 계속 사용된다면 요구사항은 계속 바뀐다. 절차지향이 처음에는 쉬울지 모르나 시간이 지나면 수정하기 어려운 구조가 되어버린다.

## 3. Object / Role / Responsibility
- 게시판을 만들때 보통 `ArticleController`, `ArticleService`, `ArticleDAO`라고 클래스명을 짓는다. 과연 이게 올바른 네이밍일까?
- `Domain Driven Design(도메인 주도 설계)`에서 보면 `WrtieArticleController`, `WrtieArticleService`, `WrtieArticleDAO`가 올바르다
- 객체를 바라볼 때 기능이 아닌 데이터를 중점으로 보게 되면 전자와 같은 네이밍을 하게될 수 밖에 없다.
- 객체/클래스 이름은 어떻게로 정의하지 말고 무엇으로 정의해야한다.
  - `RequestParser` : O
  - `JsonRequestParser` : X
- 객체는 역할(role)을 가지며 역할은 관련된 책임(Responsibility)의 집합이다.
  - 역할 > 다수의 책임들

## 4. 객체지향 설계과정
1. 기능을 제공할 객체 후보를 선별
    - 내부에서 필요한 데이터블 선별
    - 클래스 다이이어그램(erd)
    - 정적 설계
2. 객체 간 메시지 흐름 연결
    - 커뮤니케이션 다이어 그램
    - 시퀀스 다이이어그램
    - 동적설계
3. 1,2번을 수없이 반복

## 5. Encapsulation(캡슐화)
- 객체지향에서의 캡슐화는 내부적으로 어떻게 구현했는지를 감춰 내부의 변경(데이터, 코드)이 클라이언트가 변경되지 않도록 한다.
- 절차지향에서는 요구사항의 변경이 데이터 구조 변경을 유발하고 이 데이터를 사용하는 모든 코드의 수정을 유발하게 된다. 하지만 객체지향은 절차지향에 비해 확실히 작은 변경의 영향을 받고 구현변경의 유연함과 클라이언트에 영향을 미치지 않는다.
- Tell, Don't Ask(묻지말고, 지시하라)
  - 객체가 가진 데이터를 요청해서 직접 변경하고, 다시 객체에게 저장하라고 하지 않아야한다.
  - 객체 내부에 정의된 기능을 실행하도록 해야한다. 즉, 다시말해 데이터를 잘 알고 있는 객체에게 기능을 수행하라고 해야한다.
  - 이렇게 작성한다면 캡슐화가 유지되어 변경에 영향을 안받게 된다.
  - ex) 예
    ```java
    if(member.getExpiredDate().getTime() < System.currentTimeMills) {}
    ```
    ```java
    if(member.isExpired()) {}
    ```
    - 위의 if문과 아래의 if문은 동일하게 작동한다고 하면 만약 위의 if문에서 and조건이나 or조건이 더 추가된다면 이렇게 작성된 코드마다 수정해야하는 번거로움과 수정할 곳을 누락해 버그가 발생할 수도 있다.
    - 그렇기 때문에 객체 내부에서 특정 기능을 수행하도록 하는 것이 코드의 변경을 최소화할 수 있고, 버그 발생 위험도 줄일 수 있다.
- CQS(Command Query Separation)
  - Commnad(Tell) : 객체의 내부 상태 변경, 편의를 위해 어떤 결과를 반환할 수 있다.
  - Query(Ask) : 객체의 상태에 대한 정보제공, 상태 변경은 하지 않는다.

## 6. Polymorphism(다형성)
- 다형성이란? : 한 객체가 여러가지(Poly) 모습/타입(morph)을 가질 수 있다.
- 상속을 통해 다형성 구현
  - 구현 상속 : 수퍼 타입의 클래스의 구현을 사용하는 것을 일반적으로 상속이라고 부른다.
  - 인터페이스 상속 : 타입 정의만 상속, 상속은 객체에게 다형성을 제공
- 스프링에서 구현체가 하나인데 인터페이스를 쓰는 이유?
  - 구현체가 하나인지는 아무도 모른다. 변경될 가능성
  - 테스트의 용이성
  - 부가적인 기능 추가의 용이성, 디자인 패턴(Decorator)
  - 인터페이스를 쓰면 인터페이스를 사용하는 코드는 재사용된다.
    - 여기서 재사용이란 인터페이스의 구현체 `A`가 있고, 새로운 구현체 `B`라는 녀석이 생긴다면 구현체 `A`는 그대로 사용이 가능하다.

## 7. Abstraction(추상화)
- 데이터/프로세스 등을 의미가 비슷한 개념/표현으로 정의하는 과정
- 상세한 구현으로부터 개념을 도출하는 과정
- 타입 추상화
  - 공통된 데이터나 프로세스를 제공하는 객체들을 하나의 타입(인터페이스)으로 추상화하는 것
- 보통 상세한 구현에 빠지다보면 상위 수준의 설계를 놓치기 쉬운데 추상화를 통해 상위 수준의 설계를 하는 것에 도움을 얻을 수 있다.

## 8. Composition over Inheritance
- 상속을 통한 재사용 및 추가 기능을 통한 확장
  - 서브 클래스는 수퍼 클래스의 기능을 재사용함으로써 추가적인 기능을 제공하는데 이러한 방법은 상당히 쉽다. 마치 라이브러리를 사용하는 것과 같다.
  - 하지만 변경의 유연함 측면에서 치명적인 단점을 가지게 된다.
    - 수퍼 클래스의 변경이 다수의 서브 클래스에 영향을 미치게 되므로 함부로 수정할 수 없게 만든다.
    - 이러한 변경의 불가는 유사한 기능의 확장에서 클래스의 개수가 불필요하게 증가하게 한다.
- 상속보다는 Composition(delegation)의 장점
  - 유연성(변경의 용이성) 증대
  - unit test(mock) 용이
  - TDD에 용이
  - Interface의 중요성
