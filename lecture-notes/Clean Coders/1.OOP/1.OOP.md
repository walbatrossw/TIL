# Clean Coders : OOP Part 1

## 1. Why Clean Code?

**사람이 이해할 수 있는 코드(읽을수 있는 코드) VS, 기계가 이해할 수 있는 코드(돌아가는 코드)**

  - 누구나 이해할 수 있는 코드가 좋다는 것을 안다. 하지만 실무에서는 빠르게 코드를 작성해야만 한다. 바쁘기 때문에...ㅠ
  - TDD, Acceptance Test, 리팩토링, 리뷰를 할 수 없거나 안하게 된다.
  - 이렇게 프로젝트가 진행되고 론칭하게 되면 이후에 버그가 발생하게 되면 버그 수정이 쉽게 끝나지 않는다.
  - 통계적으로 본다면 코드 1라인을 수정하게되면 다시 버그가 3라인에서 발생하게 된다. 즉 다시말하자면 버그는 버그를 수정하면서 다시 발생된다.
  - 개발에 있어 앞부분에 시간과 공을 들이는 것이 처음에는 시간과 비용이 많이 드는 것처럼 보이지만 전체시간으로 본다면 결코 많이 드는 것만은 아니다.
  - 개발을 하기 앞서 종이에 한번이라도 써보면서 내가 무엇을 개발할지 고민해보는 것이 중요하다.
  - 내가 구현하려는 것이 무엇인지 고민해보고 실제로 종이나 화이트보드에 작성하는 습관을 가져보자.
  - 리팩토링과 리스트럭쳐링은 엄연히 다르다.
  - 실무에서는 프로젝트를 진행하고 나서 리팩토링을 할 시간이 없기 때문에 지금 현재에 충실히 깔끔한 코드를 작성하는 것이 매우 중요하다.

>소프트웨어는 한번 작성되면 최소 10번 이상 읽힌다. 그래서 대충 돌아가게 작성하면 안되며, 읽기 편하도록 작성해야한다.
대다수 개발자는 신규 프로젝트보다는 유지보수성 업무를 수행하는 경우가 많다. 그렇다면 답은 명확하다. 돌아가는 코드가 아닌 읽을 수 있는 코드가 중요하다는 것을


## 2. Why OOP?

**OOP(객체지향) VS, Procedural(절차지향)**

  - 절차지향
    * 데이터를 중간에 두고 그 데이터를 공유해서 사용하는 여러 함수들과 그 함수를 사용하는 또다른 함수가 존재한다.
    * 만약 데이터가 변경이 생기면 여러 함수에서 문제가 발생할 수 있다.
    * 진입장벽이 낮다.
  - 객체지향
    * 데이터를 공유해서 사용하지 않는다.
    * 데이터와 코드가 Encapsulated
    * 데이터와 그 데이터를 조작하는 코드의 변경은 외부에 영향을 미치지 않는다.
    * Coupling이 낮다.
    * 외부에 노출된 인터페이스만 변경되지 않는다면 프로시저를 실행하는데 필요한 만큼의 데이터만 가진다.
    * 진입장벽이 높다.

## 3. Object/Role/Responsibility
  - 객체/클래스 이름은 어떻게로 정의하지 말고 무엇으로 정의해야한다.
  - 객체는 역할을 가지며 역할은 관련된 책임의 집합이다.

## 4. 객체지향 설계과정
  - 기능을 제공할 객체 후보를 선별
    * 내부에서 필요한 데이터블 선별
    * 클래스 다이이어그램
    * 정적 설계
  - 객체 간 메시지 흐름 연결
    * 커뮤니케이션 다이어 그램
    * 시퀀스 다이이어그램
    * 동적설계


## 5. Encapsulation(캡슐화)

## 6. Polymorphism(다형성)

## 7. Abstraction(추상화)

## 8. Composition over Inheritance
