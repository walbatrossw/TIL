# Clean Coders : OOP Part 1

## 1. Why Clean Code?
**사람이 이해할 수 있는 코드(읽을수 있는 코드) VS, 기계가 이해할 수 있는 코드(돌아가는 코드)**

- 누구나 이해할 수 있는 코드가 좋다는 것을 안다. 하지만 실무에서는 바쁘기 때문에 빠르게 코드를 작성해야만 한다.
- 그렇기 때문에 TDD, Acceptance Test, 리팩토링, 리뷰를 할 수 없거나 안하게 된다.
- 이렇게 프로젝트를 진행하고, 론칭되면 그 이후에 발생하는 자잘한 버그들이 쉽게 수정이 되질 않는다.
- 통계적으로 본다면 코드 1라인을 수정하면 다시 버그가 3라인에서 발생된다.
- 즉 다시말하자면 버그를 수정하면서 새로운 버그가 발생하게 되는 것이다.
- 개발에 있어 앞부분에 시간과 공을 들이는 것이 처음에는 시간과 비용이 많이 드는 것처럼 보이지만 전체시간으로 본다면 결코 많이 드는 것만은 아니다.
- 개발을 하기 앞서 종이에 한번이라도 써보면서 내가 무엇을 개발할지 고민해보는 것이 중요하다.
- 내가 구현하려는 것이 무엇인지 고민해보고 실제로 종이나 화이트보드에 작성하는 습관을 가져보자.
- 리팩토링과 리스트럭쳐링은 엄연히 다르다.
- 실무에서는 프로젝트를 진행하고 나서 리팩토링을 할 시간이 없기 때문에 지금 현재에 충실히 깔끔한 코드를 작성하는 것이 매우 중요하다.

>소프트웨어는 한번 작성되면 최소 10번 이상 읽힌다. 그래서 대충 돌아가게 작성하면 안되며, 읽기 편하도록 작성해야한다.
대다수 개발자는 신규 프로젝트보다는 유지보수성 업무를 수행하는 경우가 많다. 그렇다면 답은 명확하다. 돌아가는 코드가 아닌 읽을 수 있는 코드가 중요하다는 것을


## 2. Why OOP?
**OOP(객체지향) VS, Procedural(절차지향)**
- 절차지향
  * 데이터를 중간에 두고 그 데이터를 공유해서 사용하는 여러 함수들과 그 함수를 사용하는 또다른 함수가 존재한다.
  * 만약 데이터가 변경이 생기면 여러 함수에서 문제가 발생할 수 있다.
  * 절차지향의 경우 진입장벽이 상대적으로 낮고 쉽다.
- 객체지향
  * 데이터를 공유해서 사용하지 않는다.
  * 데이터와 코드가 캡슐화(Encapsulated)
  * 데이터와 그 데이터를 조작하는 코드의 변경은 외부에 영향을 미치지 않는다.
  * 응집도가 높고 결합도가 낮다.
  * 외부에 노출된 인터페이스만 변경되지 않는다면 프로시저를 실행하는데 필요한 만큼의 데이터만 가진다.
  * 진입장벽이 높고 어렵다.
  * 현실적으로 어렵기 때문에 절차지향에서 객체지향으로 수정하는 리팩토링을 하는 것이 현실적이다.

> 소프트웨어는 계속 사용된다면 요구사항은 계속 바뀐다. 절차지향이 처음에는 쉬울지 모르나 시간이 지나면 수정하기 어려운 구조가 되어버린다.

## 3. Object / Role / Responsibility
- 게시판을 만들때 보통 `ArticleController`, `ArticleService`, `ArticleDAO`라고 클래스명을 짓는다. 과연 이게 올바른 네이밍일까?
- `Domain Driven Design(도메인 주도 설계)`에서 보면 `WrtieArticleController`, `WrtieArticleService`, `WrtieArticleDAO`가 올바르다
- 객체를 바라볼 때 기능이 아닌 데이터를 중점으로 보게 되면 전자와 같은 네이밍을 하게될 수 밖에 없다.
- 객체/클래스 이름은 어떻게로 정의하지 말고 무엇으로 정의해야한다.
  - `RequestParser` : O
  - `JsonRequestParser` : X
- 객체는 역할(role)을 가지며 역할은 관련된 책임(Responsibility)의 집합이다.
  - 역할 > 다수의 책임들

## 4. 객체지향 설계과정
1. 기능을 제공할 객체 후보를 선별
    - 내부에서 필요한 데이터블 선별
    - 클래스 다이이어그램(erd)
    - 정적 설계
2. 객체 간 메시지 흐름 연결
    - 커뮤니케이션 다이어 그램
    - 시퀀스 다이이어그램
    - 동적설계
3. 1,2 번을 반복
4.

## 5. Encapsulation(캡슐화)
- 객체지향에서의 캡슐화는 내부적으로 어떻게 구현했는지를 감춰 내부의 변경(데이터, 코드)이 client가 변경되지 않도록 한다. 즉, 다시말해 코드 변경에 따른 비용을 최소화 할 수 있다.
- 절차지향에서는 요구사항의 변경이 데이터 구조 변경을 유발하고 이 데이터를 사용하는 모든 코드의 수정을 유발하게 된다.

## 6. Polymorphism(다형성)

## 7. Abstraction(추상화)

## 8. Composition over Inheritance
